<!DOCTYPE html><html><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="破晓晨曦的个人笔记Blog，用于记录学习感悟及前沿技术。Xaviershi的博客。"><meta name="keywords" content="博客,个人博客,Xaviershi,XS个人博客,技术博客,XS,全栈工程师,破晓晨曦"><meta name="author" content="XS,破晓晨曦"><meta name="copyright" content="Xavier"><meta name="baidu-site-verification" content="eCDWBwIWCq"><title>JS高级-一刷红宝书 | XS's Blog</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.3"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?e1c52888bff53137a720a05b1ab9eaa6";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><script>var GLOBAL = { 
  root: '/',
  algolia: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  localSearch: {"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"},"path":"search.xml"}
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#JS高级-一刷红宝书"><span class="toc-number">1.</span> <span class="toc-text">JS高级-一刷红宝书</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaScript简介"><span class="toc-number">1.1.</span> <span class="toc-text">JavaScript简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在HTML中使用JavaScript"><span class="toc-number">1.2.</span> <span class="toc-text">在HTML中使用JavaScript</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基本概念"><span class="toc-number">1.3.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#变量、作用域、内存问题"><span class="toc-number">1.4.</span> <span class="toc-text">变量、作用域、内存问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#引用类型"><span class="toc-number">1.5.</span> <span class="toc-text">引用类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面向对象的程序设计"><span class="toc-number">1.6.</span> <span class="toc-text">面向对象的程序设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#继承"><span class="toc-number">1.7.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数表达式"><span class="toc-number">1.8.</span> <span class="toc-text">函数表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#location对象"><span class="toc-number">1.8.1.</span> <span class="toc-text">location对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#navigator对象和screen对象"><span class="toc-number">1.8.2.</span> <span class="toc-text">navigator对象和screen对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#客户端检测-暂且跳过"><span class="toc-number">1.9.</span> <span class="toc-text">客户端检测 暂且跳过</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM-★★★"><span class="toc-number">1.10.</span> <span class="toc-text">DOM ★★★</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#利用document取得文档信息"><span class="toc-number">1.10.1.</span> <span class="toc-text">利用document取得文档信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Element类型"><span class="toc-number">1.10.2.</span> <span class="toc-text">Element类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM扩展"><span class="toc-number">1.11.</span> <span class="toc-text">DOM扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#与类相关的扩展"><span class="toc-number">1.11.1.</span> <span class="toc-text">与类相关的扩展</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM2和DOM3"><span class="toc-number">1.12.</span> <span class="toc-text">DOM2和DOM3</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#样式"><span class="toc-number">1.12.1.</span> <span class="toc-text">样式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DOM范围-暂时略过"><span class="toc-number">1.12.2.</span> <span class="toc-text">DOM范围 暂时略过</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事件"><span class="toc-number">1.13.</span> <span class="toc-text">事件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DOM-2级事件处理程序"><span class="toc-number">1.13.1.</span> <span class="toc-text">DOM 2级事件处理程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#事件类型"><span class="toc-number">1.13.2.</span> <span class="toc-text">事件类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#UI事件"><span class="toc-number">1.13.2.1.</span> <span class="toc-text">UI事件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#焦点事件"><span class="toc-number">1.13.2.2.</span> <span class="toc-text">焦点事件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#鼠标与滚轮事件"><span class="toc-number">1.13.2.3.</span> <span class="toc-text">鼠标与滚轮事件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#键盘事件"><span class="toc-number">1.13.2.4.</span> <span class="toc-text">键盘事件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#DOM变动事件"><span class="toc-number">1.13.2.5.</span> <span class="toc-text">DOM变动事件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#各种页面事件还有很多啊"><span class="toc-number">1.13.2.6.</span> <span class="toc-text">各种页面事件还有很多啊</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#触摸事件"><span class="toc-number">1.13.2.7.</span> <span class="toc-text">触摸事件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#事件委托"><span class="toc-number">1.13.2.8.</span> <span class="toc-text">事件委托</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#移除事件处理程序"><span class="toc-number">1.13.2.9.</span> <span class="toc-text">移除事件处理程序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#模拟事件"><span class="toc-number">1.13.2.10.</span> <span class="toc-text">模拟事件</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#自定义事件-★★★★★"><span class="toc-number">1.13.3.</span> <span class="toc-text">自定义事件 ★★★★★</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#表单脚本"><span class="toc-number">1.14.</span> <span class="toc-text">表单脚本</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#操作剪贴板"><span class="toc-number">1.14.1.</span> <span class="toc-text">操作剪贴板</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#富文本-比较nb的-先过"><span class="toc-number">1.14.2.</span> <span class="toc-text">富文本 比较nb的 先过</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#canvas"><span class="toc-number">1.15.</span> <span class="toc-text">canvas</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#webGL提供了一些操作字节级别的方法"><span class="toc-number">1.15.1.</span> <span class="toc-text">webGL提供了一些操作字节级别的方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTML5脚本编程"><span class="toc-number">1.16.</span> <span class="toc-text">HTML5脚本编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#拖动"><span class="toc-number">1.16.1.</span> <span class="toc-text">拖动</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ajax-XMLHttpRequest"><span class="toc-number">1.17.</span> <span class="toc-text">ajax XMLHttpRequest</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#websocket-并不难"><span class="toc-number">1.17.1.</span> <span class="toc-text">websocket 并不难</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#js高级技巧"><span class="toc-number">1.18.</span> <span class="toc-text">js高级技巧</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/dalao.jpg"></div><div class="author-info__name text-center">Xavier</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">28</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">7</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">1</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/top_img/2.jpg);"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">XS's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title-box"><div id="post-title">JS高级-一刷红宝书</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-05-14</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/js/">js</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2018/05/14/JS高级-一刷红宝书/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2018/05/14/JS高级-一刷红宝书/"></span></a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">7,509</span><span class="post-meta__separator">|</span><span>阅读时长: 27 分钟</span></div></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div id="post-content"><h2 id="JS高级-一刷红宝书"><a href="#JS高级-一刷红宝书" class="headerlink" title="JS高级-一刷红宝书"></a>JS高级-一刷红宝书</h2><h3 id="JavaScript简介"><a href="#JavaScript简介" class="headerlink" title="JavaScript简介"></a>JavaScript简介</h3><ul>
<li><p>文档对象模型(DOM)</p>
<blockquote>
<p>很多语言也实现了DOM，但是DOM已经成为了JavaScript中的一个重要组成部分  </p>
</blockquote>
</li>
<li><p>JavaScript由ECMAScript + 文档对象模型(DOM) + 浏览器对象模型(BOM)组成</p>
</li>
<li>浏览器http请求限制 8以内<br><a href="https://www.zhihu.com/question/20474326" target="_blank" rel="noopener">浏览器允许的并发请求资源数是什么意思？</a><br><a href="http://www.cnblogs.com/liuyanan/p/5242192.html" target="_blank" rel="noopener">页面优化——减少HTTP请求数</a>  </li>
<li>为什么使用CDN的原因<br>启用与主站域名不同的网站提供静态服务可以减少cookies传送 有的时候cookies体积很大，而每一个请求都会携带cookies往返，占用时间和带宽较大,并且能够减少服务器带宽 节约资源<a id="more"></a>
<h3 id="在HTML中使用JavaScript"><a href="#在HTML中使用JavaScript" class="headerlink" title="在HTML中使用JavaScript"></a>在HTML中使用JavaScript</h3></li>
<li><p>script标签的属性<br><a href="http://www.cnblogs.com/AndyWithPassion/archive/2011/09/03/2165441.html" target="_blank" rel="noopener">script之defer&amp;async</a><br><a href="http://www.w3school.com.cn/html5/att_script_async.asp" target="_blank" rel="noopener">HTML 5 script async 属性</a>  </p>
<blockquote>
<p>async 下载后立即执行 defer 文档解析后执行</p>
</blockquote>
</li>
<li><p>外部js文件的后缀名不一定是js 但是要确保服务器返回正确的MIME类型  </p>
</li>
<li>为什么要将script标签放在页面后面<br>浏览器在遇到<code>&lt;body&gt;</code>标签时才开始呈现页面内容,如果将script标签放在head里面会导致浏览器必须将全部js下载、解析、执行，js代码过多会导致页面出现明显延迟，表现为白屏，因此现代WEB应用一般将script标签放在<code>&lt;/body&gt;</code>前面。</li>
<li>js代码放入外部文件<br>1. 可维护性  <ol>
<li>共用js提高页面加载速度  </li>
<li>不与浏览器解析html冲突</li>
</ol>
</li>
<li>noscript标签用于在不支持js或者禁用js的浏览器上面插入内容<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3></li>
<li><code>var message</code>这种未初始化的变量保存一个特殊的值 undefined  </li>
<li>JS数据类型拥有动态性，相同的变量可以用作不同的类型。</li>
<li>调用<code>typeof null</code>返回一个对象类型 特殊值null被认作是空的对象引用</li>
<li><code>typeof **</code>返回的undefined可能是未初始化也可能是未声明 </li>
<li><code>null == undefined</code> true <code>null === undefined</code> false</li>
<li>number类型 IEEE754格式</li>
<li><code>typeof NaN</code> number</li>
<li>任何涉及NaN的操作都会返回NaN NaN与任何值不等 包括它自己 </li>
<li>在chrome中 任何数值除以0都会返回 Infinity</li>
<li>字符串创建之后不可变 赋值是重新生成空间然后销毁替换</li>
<li>对一个对象里面的数组使用for in 遍历 可能会出问题 遍历结果和数组并不一样</li>
<li>arguments获取的是传的参数个数而不是定义时的参数个数<h3 id="变量、作用域、内存问题"><a href="#变量、作用域、内存问题" class="headerlink" title="变量、作用域、内存问题"></a>变量、作用域、内存问题</h3></li>
<li>所谓的函数参数按值传递：<br>基本类型变量复制是复制的值，复制完毕不会互相影响<br>引用类型变量复制的是引用地址即指针，复制完毕会互相影响<br>而函数接受的参数 就是单纯的值 可能是值或指针<br>但是如果重新new一个obj那么新的obj做的改变不会指向外部的对象</li>
<li>用typeof检测基本数据类型 用instanceof检测引用数据类型 </li>
<li>一般函数内部的this指向的是调用函数的环境 但是使用new构造一个实例会改变this的指向</li>
<li>try catch和with能延长作用域链</li>
<li>内存回收<br>一般是采用标记清除的方式回收而不是采用引用计数的方式回收  </li>
<li>手动回收内存<br>除了调用浏览器提供的方法 手动的一个方法是将全局变量设置为null 局部变量一般不用关心 -这种做法叫解除引用</li>
<li>基本类型值占据大小固定空间 在栈内存中  引用类型的值是对象 在堆内存中<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3></li>
<li>array能通过使用push、pop、shift、unshift来实现栈和队列等 </li>
<li>push方法在数组末尾添加元素</li>
<li>pop方法移除数组末尾的元素</li>
<li>shift方法移除数组开头的元素</li>
<li>unshift方法向数组开头添加元素 </li>
<li>可以用push+pop实现栈 用push+shift实现队列 unshift+pop实现反向队列</li>
<li>数组除了操作数组的几个方法 concat、includes、indexOf、join、lastIndexOf、slice  </li>
<li>几个迭代方法 every、some、filter、find、findIndex、forEach、keys、map、reduce、reduceRight、values</li>
<li>Date类型 JSON.stringify(new Date()) 和Date.toString()不一样  </li>
<li>处理时间的库 <a href="https://github.com/iamkun/dayjs" target="_blank" rel="noopener">dayjs</a>  <a href="https://github.com/moment/moment" target="_blank" rel="noopener">momentjs</a></li>
<li>使用var创建普通变量会引起变量提升 使用函数声明也会引起变量提升 但是使用函数表达式并不会引起变量提升</li>
<li>函数如果没有return则返回undefined 有则返回return的值</li>
<li>函数内部arguments对象的callee方法指向自身函数</li>
<li>arguments的caller指向调用自身函数的函数的引用</li>
<li>函数的apply()和call()能改变this的指向 第一个参数都是传的作用域 即可以传对象等 第二个参数是参数值 apply能传数组和arguments call只能列出每一项传 不过es6有…方式进行解构赋值</li>
<li>bind方法也能绑定this的值<br>- 基本数据类型是没有方法的 那么为什么能直接使用方法呢 例如 a1.substring(2)<br>这是因为js做了如下操作<br>当执行上述代码时 访问a1处于一种读取模式  <ol>
<li>创建String类型的一个实例</li>
<li>在实例上调用指定的方法</li>
<li>销毁这个实例 </li>
</ol>
</li>
<li>js 三种特殊引用类型 String Boolean Number  称作基本包装类型</li>
<li>引用类型和基本包装类型的区别是对象的生存期问题</li>
<li>字符串操作方法  <ol>
<li>concat()连接字符串 不过现在一般用+</li>
<li>slice substr substring</li>
<li>indexOf lastIndexOf</li>
<li>trim 去空格</li>
<li>toLowerCase toUpperCase toLocalLowerCase toLocalUpperCase</li>
<li>match 方法与正则的 exec()方法相同</li>
<li>search replace search返回索引值 </li>
<li>split分割字符串成数组</li>
</ol>
</li>
<li>全局对象 Global<br>parseInt()等方法其实都是属于Global的方法  encodeURI() decodeURI() encodeURIComponent() </li>
<li>web浏览器将Global实现在了window对象中</li>
<li><p>Math</p>
<ul>
<li><p>min和max方法 一般是将很多参数当参数传入 但是也可以这么做</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">98</span>, <span class="number">9</span>, <span class="number">0</span>]</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">Math</span>.min.apply(<span class="built_in">Math</span>, a) <span class="comment">//0</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, a) <span class="comment">//98</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>舍入方式 Math.ceil()向上取整 Math.floor()向下取整 Math.round()标准取整</p>
</li>
<li>Math.random()随机数方法 Math.floor(Math.random()*一个整数+一个整数)</li>
<li>遍历数组用for循环、for of forEach 尽量不用for in <h3 id="面向对象的程序设计"><a href="#面向对象的程序设计" class="headerlink" title="面向对象的程序设计"></a>面向对象的程序设计</h3></li>
</ul>
</li>
<li>属性类型<ul>
<li>数据属性<br>包含 可定义 可枚举 可读写 value值</li>
<li>访问器属性<br>包含getter setter方法 必须用defineProperty()来定义</li>
<li>在js中 可以对任何对象 包括DOM和BOM对象 使用Object.getOwnPropertyDescriptor()方法</li>
</ul>
</li>
<li><p>创建对象 ★★★★★</p>
<ol>
<li>工厂模式  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">  o.name = name</span><br><span class="line">  o.age = age</span><br><span class="line">  o.job = job</span><br><span class="line">  o.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> o</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">'nick'</span>, <span class="number">29</span>, <span class="string">'Software Engineer'</span>)</span><br><span class="line"><span class="keyword">var</span> person2 = createPerson(<span class="string">'Greg'</span>, <span class="number">27</span>, <span class="string">'Doctor'</span>)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>解决创建多个相似对象的问题，却没有解决对象识别问题</p>
<ol>
<li>构造函数模式<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="keyword">this</span>.job = job</span><br><span class="line">  <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'nick'</span>, <span class="number">29</span>, <span class="string">'Software Engineer'</span>)</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">'Greg'</span>, <span class="number">27</span>, <span class="string">'Doctor'</span>)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>没有显示的创建对象</li>
<li>将属性和方法直接赋值给了this对象</li>
<li>没有return 语句</li>
<li>开头使用了大写P 这是想OO语言看齐 </li>
<li>必须使用new操作符创建实例 使用new操作符经历了以下过程<ul>
<li>创建一个新对象</li>
<li>将构造函数的作用域赋给新对象 因此this就指向了这个对象</li>
<li>执行构造函数代码 添加属性和方法</li>
<li>返回新对象</li>
</ul>
</li>
<li>这两种创建的对象不大一样 </li>
<li>构造函数创建的对象的constructor(构造函数)属性 指向Person 最初是用来标识对象类型的 使用<code>person1 instanceof Objcet</code>返回true <code>person1 instanceof Person</code>返回true </li>
<li>构造函数创建的每一个实例的方法都是不相等的 因为函数是对象 定义一个函数就相当于创建了一个对象  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person3.sayName == person4.sayName  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>于是他们把共同作用的函数拿出来做成全局函数 然后每个实例的引用指向这个函数  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">    <span class="keyword">this</span>.job = job</span><br><span class="line">    <span class="keyword">this</span>.sayName = sayName</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">然后问题又来了，首先这个全局函数只能对象用，不符合全局函数的定义，其次如果方法很多就要定义很多全局函数，那么这个类就没有封装性可言了  </span></span><br><span class="line"><span class="string">2. 原型模式</span></span><br><span class="line"><span class="string">&gt; 程序员真会玩  </span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  User.prototype.name = <span class="string">'Mike'</span></span><br><span class="line">  User.prototype.age = <span class="number">29</span></span><br><span class="line">  User.prototype.job = <span class="string">'Software Engineer'</span></span><br><span class="line">  User.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> user1 = <span class="keyword">new</span> User()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>prototype 就是通过调用构造函数而创建的那个对象实例的原型对象  </p>
</blockquote>
<ul>
<li>Object.getPrototypeOf()方法取得实例的原型对象 </li>
<li>对象实例的属性和方法会覆盖原型的属性和方法 但是不会修改 使用delete操作符删除实例属性并能回复对原型访问 </li>
<li>使用hasOwnProperty()方法判断属性在实例中还是在原型中，返回true代表在实例中 hasOwnProperty是从Object继承而来的</li>
<li>为原型添加方法或属性或者修改，能够立即在所有对象实例中反应出来</li>
<li>原型模式共享属性和方法既是优点也是缺点</li>
<li>不能在实例化对象之后使用字面量方式重写原型 否则会切断现有实例与新原型之间的联系</li>
</ul>
</li>
</ul>
<ol>
<li><p>组合使用构造函数模式和原型模式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="keyword">this</span>.job = job</span><br><span class="line">  <span class="keyword">this</span>.friends = [<span class="string">'Shelby'</span>, <span class="string">'Court'</span>]</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: Person,</span><br><span class="line">  sayName: function () &#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'Nicholas'</span>, <span class="number">29</span>, <span class="string">'software engineer'</span>)</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">'Greg'</span>, <span class="number">27</span>, <span class="string">'Doctor'</span>)</span><br></pre></td></tr></table></figure>
<p>集合两种模式之长，是现在使用最广泛、认同度最高的一种创建自定义类型的方法</p>
</li>
<li>动态原型模式<br>在构造函数中添加一个初始化原型方法的if语句</li>
<li>寄生构造函数模式 稳妥构造函数模式</li>
</ol>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>js只支持实现继承 并且主要依靠原型链来实现继承  </p>
<ul>
<li>原型链继承实现<ol>
<li>简单点来说就是定义一个father类型</li>
<li>father类型加点原型方法 </li>
<li>定义一个children类型 children原型 = father的实例</li>
<li>children类型加点原型方法</li>
<li>结果：father类型有自己的原型方法 children类型有father类型实例的属性和方法还有它自己定义的方法</li>
</ol>
</li>
<li>注意使用对象字面量方式替换原型 很可能会导致切断联系</li>
<li>原型链的两个问题：1 子类型的所有实例会共享父类型的引用类型值 比如数组 2 子类型创建实例的时候，不能在不影响所有对象实例的情况下向超类型的构造函数中传递参数</li>
<li><p>借用构造函数  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'yellow'</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  SuperType.call(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>借用构造函数是能解决上面两个问题的，不过它也有自己的问题，那就是方法都定义在构造函数中 子类没法用超类定义的方法</p>
</li>
<li><p>组合继承<br>组合继承，有时候也会叫做伪经典继承，指的是将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种模式。其背后思路是使用原型链实现对原型属性和方法的继承，使用借用构造函数来实现对实例属性的继承。这样既能在原型上定义方法实现了函数复用，有能够保证每个势力都有他自己的属性！  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'yellow'</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 借用构造函数 继承属性</span></span><br><span class="line">  SuperType.call(<span class="keyword">this</span>, name)</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承方法</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType()</span><br><span class="line">SubType.prototype.constructor = SubType</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">'Nicholas'</span>, <span class="number">29</span>)</span><br><span class="line">instance1.colors.push(<span class="string">'black'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);</span><br><span class="line">instance1.sayName()</span><br><span class="line">instance1.sayAge()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">'Greg'</span>, <span class="number">27</span>)</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors);</span><br><span class="line">instance2.sayName()</span><br><span class="line">instance2.sayAge()</span><br><span class="line"></span><br><span class="line">[ <span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'yellow'</span>, <span class="string">'black'</span> ]</span><br><span class="line">Nicholas</span><br><span class="line"><span class="number">29</span></span><br><span class="line">[ <span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'yellow'</span> ]</span><br><span class="line">Greg</span><br><span class="line"><span class="number">27</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>原型式继承<br>Object.create() 以传入的对象做原型创建一个新的对象  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">'make'</span>,</span><br><span class="line">  friends: [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="built_in">Object</span>.create(person, &#123;</span><br><span class="line">  age: &#123;</span><br><span class="line">    value: <span class="number">12</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(person1.age); <span class="comment">//12</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.name); <span class="comment">//make</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>直接打印person1不显示，但是能.出来 因为属性都在原型里面。潜复制 引用指向相同的值</p>
<ul>
<li>寄生式继承<br>核心是封装继承过程的函数，步骤是 调用函数创建一个新对象 增强这个对象 返回这个对象</li>
<li>寄生组合式继承<br>组合式继承虽然使用最广泛，但是他调用超类的构造函数有两次。于是程序员们使用寄生组合式继承，在<code>SubType.prototype = new SuperType()</code>第一次调用构造函数的这个地方更改为寄生式继承的方式 即  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> prototype = object(superType.prototype)</span><br><span class="line">  prototype.constructor = subType</span><br><span class="line">  subType.prototype = prototype</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>相当于在继承的时候子类原型只接受了父类原型，而没有调用构造函数</p>
<h3 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h3><p>函数有函数声明提升，使用函数表达式创建的函数没有声明提升</p>
<blockquote>
<p>闭包：闭包是指有权访问另一个函数作用域中的变量的函数。</p>
</blockquote>
<p>最简单的闭包就是函数里面写一个函数。<br>调用函数发生的事：创建一个执行环境 创建一个活动对象 内部包含arguments 命名参数等 一般函数执行完毕后活动对象就被销毁 但是闭包引用了活动对象的值就不会令它简单销毁  </p>
<ul>
<li>闭包与变量  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> res = <span class="keyword">new</span> <span class="built_in">Array</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    res[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a1 = a()</span><br><span class="line"><span class="built_in">console</span>.log(a1);</span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">这段代码的返回结果是 `</span>[ [<span class="built_in">Function</span>],</span><br><span class="line">  [<span class="built_in">Function</span>],</span><br><span class="line">  [<span class="built_in">Function</span>],</span><br><span class="line">  [<span class="built_in">Function</span>],</span><br><span class="line">  [<span class="built_in">Function</span>],</span><br><span class="line">  [<span class="built_in">Function</span>],</span><br><span class="line">  [<span class="built_in">Function</span>],</span><br><span class="line">  [<span class="built_in">Function</span>],</span><br><span class="line">  [<span class="built_in">Function</span>],</span><br><span class="line">  [<span class="built_in">Function</span>] ]<span class="string">` 一个函数数组，但实际上 每个函数都返回10，因为每个函数的作用域链都保存着a的活动对象，即他们引用的都是同一个i。当循环执行完之后，i的值为10，所以每个函数都返回10。  </span></span><br><span class="line"><span class="string">  改进版  </span></span><br><span class="line"><span class="string">  `</span><span class="string">``</span>js</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> res = <span class="keyword">new</span> <span class="built_in">Array</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    res[i] = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a1 = a()</span><br><span class="line"><span class="built_in">console</span>.log(a1);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>多加了一个带参的匿名函数，由于函数参数是按值传递的，所以会将i复制给num，这样闭包返回的值都是不同的。  </p>
<ul>
<li>关于this对象<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'The Window'</span></span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">  name: <span class="string">' My object'</span>,</span><br><span class="line">  getNameFunc: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);<span class="comment">//My object</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.name <span class="comment">//The Window</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(object.getNameFunc()());</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>匿名函数的执行环境具有全局性，this通常指向window。<br>改进<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'The Window'</span></span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">  name: <span class="string">' My object'</span>,</span><br><span class="line">  getNameFunc: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);<span class="comment">//My object</span></span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> that.name <span class="comment">//My object</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(object.getNameFunc()());</span><br><span class="line"><span class="string">``</span><span class="string">`  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">使用that或者_this保存下this的值,亦或者使用箭头函数。  </span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'The Window'</span></span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">  name: <span class="string">' My object'</span>,</span><br><span class="line">  getNameFunc: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(object.getNameFunc()());</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>模仿块级作用域</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">//报错</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>190页 单例模式 </p>
</li>
<li>现在想想 回调函数真jb骚<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  callback()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'b'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a(b)</span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">主要意思就是将一个函数作为参数传给主函数，主函数执行完毕执行回调函数，这个过程主函数可以传递参数给回调函数，然后回调函数就能拿到主函数执行完毕的一些变量。  </span></span><br><span class="line"><span class="string">回调函数也是闭包，我们通常使用一般不会特地声明回调函数，而是直接调用主函数然后传一个匿名参数做回调函数，回调函数拿到的参数必定是主函数执行完毕的值。也就是说使用回调函数相当于先执行完主函数。  </span></span><br><span class="line"><span class="string">### BOM</span></span><br><span class="line"><span class="string">#### window对象</span></span><br><span class="line"><span class="string">- 每个frame都有自己的window对象 可以使用window.frames[]或者top. parent.方式来访问每个frame的window对象</span></span><br><span class="line"><span class="string">- 窗口位置</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line"><span class="keyword">var</span> leftPos = (<span class="keyword">typeof</span> <span class="built_in">window</span>.screenLeft === <span class="string">"number"</span>) ? <span class="built_in">window</span>.screenLeft : <span class="built_in">window</span>.screenX;</span><br><span class="line"><span class="keyword">var</span> topPos = (<span class="keyword">typeof</span> <span class="built_in">window</span>.screenTop === <span class="string">"number"</span>) ? <span class="built_in">window</span>.screenTop : <span class="built_in">window</span>.screenY;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>moveTo moveBy 这种js控制浏览器的方法好多浏览器已经禁用，好像IE可能有用</p>
<ul>
<li><p>窗口大小<br>由于浏览器之间的各个差异，因此最终虽然无法确定浏览器窗口本身大小，不过可以取得页面视口的大小</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pageWidth = <span class="built_in">window</span>.innerWidth;</span><br><span class="line"><span class="keyword">var</span> pageHeight = <span class="built_in">window</span>.innerHeight;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> pageWidth !== <span class="string">"number"</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">document</span>.compatMode === <span class="string">"CSS1Compat"</span>) &#123;</span><br><span class="line">    pageWidth = <span class="built_in">document</span>.documentElement.clientWidth;</span><br><span class="line">    pageHeight = <span class="built_in">document</span>.documentElement.clientHeight;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    pageWidth = <span class="built_in">document</span>.body.clientWidth;</span><br><span class="line">    pageHeight = <span class="built_in">document</span>.body.clientHeight;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>导航和打开窗口</p>
<ol>
<li><code>window.open()</code>返回一个指向新窗口的引用。调用<code>window.close()</code>可以关闭打开的窗口。</li>
<li>opener属性指向打开窗口的原始窗口</li>
</ol>
</li>
<li><p>间歇调用和超时调用<br>setTimeout 尽量传函数而不是字符串，为了避免性能的损耗。<br>使用setTimeout经过指定时间代码不一定会执行。  </p>
<blockquote>
<p>js是一个单线程的解释器，因此一定时间内只能执行一段代码。为了控制要执行的代码，就有一个js的任务队列。这些任务会按照将它们添加到队列的顺序执行。setTimeout的第二个为时间的参数是告诉js再过多长时间将当前任务添加到队列，如果队列是空的那么代码立即执行，如果队列不是空的需要等前面任务执行完了以后再执行。</p>
</blockquote>
<p>换句话说就是setTimeout指定时间之后将任务添加到队列末尾。<br>不建议在开发环境使用setInterval 而是使用setTimeout模拟。</p>
</li>
<li>系统对话框<ul>
<li>confirm返回一个boolean true代表按了确认 false则是取消或者x</li>
<li>prompt 两个参数 一个是提示 一个是输入框默认值 返回用户输入或者null</li>
<li>还有查找和打印两个异步对话框 window.find() window.print()<h4 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h4>location对象既是window对象的属性，也是document对象的属性。<br>location的几个属性<br>hash返回url的hash、host返回服务器名称和端口号、hostname 服务器名称、href 完整url、pathname 返回url文件目录名、port 服务器端口、protocol返回页面使用协议、search 返回url查询字符串<h4 id="navigator对象和screen对象"><a href="#navigator对象和screen对象" class="headerlink" title="navigator对象和screen对象"></a>navigator对象和screen对象</h4>navigator对象包含了浏览器相关的信息<br>screen对象包含了屏幕显示相关的信息，但是一般不敢使用screen的宽高来设置元素<h3 id="客户端检测-暂且跳过"><a href="#客户端检测-暂且跳过" class="headerlink" title="客户端检测 暂且跳过"></a>客户端检测 暂且跳过</h3><a href="https://blog.csdn.net/kongjiea/article/details/17612899" target="_blank" rel="noopener">js判断客户端是pc端还是移动端</a><h3 id="DOM-★★★"><a href="#DOM-★★★" class="headerlink" title="DOM ★★★"></a>DOM ★★★</h3>document对象是HTMLDocument的一个实例，表示整个HTML页面。而且，document对象是window对象的一个属性，因此可以将其作为全局对象来访问。<br>documentElement属性指向html元素，body属性指向body元素。<h4 id="利用document取得文档信息"><a href="#利用document取得文档信息" class="headerlink" title="利用document取得文档信息"></a>利用document取得文档信息</h4></li>
</ul>
</li>
<li>document.title 取得title标签的信息并且可以修改</li>
<li>document.URL 包含完整的URL信息</li>
<li>document.domain 取得页面的域名</li>
<li>document.referrer 取得页面的来源页</li>
<li>以上信息都存于http头部</li>
<li>document.write 具有写入页面的能力<h4 id="Element类型"><a href="#Element类型" class="headerlink" title="Element类型"></a>Element类型</h4>获取到元素之后 它的属性一般直接点出来就可以 也可以通过点进行赋值。  但是自定义属性没法点出来 可以使用<code>getAttribute()</code>取得,还有<code>setAttribute()</code> <code>removeAttribute()</code>等方法。<br>一般不使用getAttribute方式，因为还有style和onclick等方式取得的是对象。<br>Text类型  </li>
<li>例如div.firstChild取得 然后使用nodeValue修改  </li>
</ul>
<p>DOM操作技术</p>
<ul>
<li>动态加载的js代码能立即执行</li>
</ul>
<h3 id="DOM扩展"><a href="#DOM扩展" class="headerlink" title="DOM扩展"></a>DOM扩展</h3><p>js现在已经原生支持使用css选择符选择元素 <code>querySelector</code> <code>querySelectAll</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div2 = <span class="built_in">document</span>.querySelector(<span class="string">'#divc'</span>)</span><br></pre></td></tr></table></figure></p>
<h4 id="与类相关的扩展"><a href="#与类相关的扩展" class="headerlink" title="与类相关的扩展"></a>与类相关的扩展</h4><p><code>getElementsByClassName</code>返回一个nodelist。<br><code>classList</code>属性 返回一个元素的class数组，然后附带有remove、add<br>、toggle、contains(是否包含)等方法。<br><code>document.activeElement</code>获取文档中获得焦点的元素,hasFocus()方法判断文档是否有焦点。<br><code>children</code>获取节点的子元素 <code>contains</code>方法判断是否是节点的子节点。  </p>
<h3 id="DOM2和DOM3"><a href="#DOM2和DOM3" class="headerlink" title="DOM2和DOM3"></a>DOM2和DOM3</h3><p>变化有点看不大懂 先pass  </p>
<h4 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h4><p>.style方式改变样式时，float改成cssFloat IE下则是styleFloat<br>获取样式表样式 <code>getComputedStyle(document.getElementById(&#39;wrap&#39;))</code> <code>currentStyle</code> </p>
<ul>
<li>偏移量<br>offsetHeight 元素垂直方向上的空间大小 以像素记 包括元素高度 水平滚动条高度 上下边框高度<br>offsetWidth 包括元素宽度 垂直滚动条宽度 左右边框<br>offsetLeft 元素左边框至包含元素左边框距离<br>offsetTop 元素上边框至包含元素上边框距离  </li>
<li>客户区大小<br>clientHeight 元素内容高度加上上下内边距高度<br>clientWidth 元素内容宽度加上左右内边距宽度<h4 id="DOM范围-暂时略过"><a href="#DOM范围-暂时略过" class="headerlink" title="DOM范围 暂时略过"></a>DOM范围 暂时略过</h4></li>
</ul>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>事件分为两种：事件冒泡和事件捕获<br>DOM事件流：现在的DOM事件流是先捕获再冒泡<br>一种事件处理程序是直接在html上面使用on方式  </p>
<ul>
<li>第一个缺点 由于事件绑定在元素上 因此若是函数不具备执行条件然后被触发 会导致报错 </li>
<li>第二个缺点 扩展事件处理程序的作用域链在不同浏览器中会导致不同结果 </li>
<li>html和js代码耦合度高<br>DOM 0级事件处理程序 </li>
<li>简单 跨浏览器 取得一个元素的引用 然后 <code>btn.onclick = function(){}</code> 函数里的this引用的是这个元素的属性和方法  <h4 id="DOM-2级事件处理程序"><a href="#DOM-2级事件处理程序" class="headerlink" title="DOM 2级事件处理程序"></a>DOM 2级事件处理程序</h4>DOM2级事件处理程序使用<code>addEventListener()</code>和<code>removeEventListener()</code>。所有DOM节点中都包含这两个方法，并且它们都接受三个参数：要处理的事件名，事件处理程序函数和一个布尔值。布尔值为true表示捕获阶段调用事件处理程序，false代表冒泡阶段调用事件处理程序。<br>removeEventListener要移除事件，必须要是命名函数，使用匿名函数方式绑定的事件无法使用remove移除。<br>不建议在捕获阶段添加事件处理程序。<br><code>event.preventDefault()</code>用来阻止特定事件的默认行为。<br><code>event.stopPropagation()</code>用来阻止元素继续冒泡。  <h4 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h4><h5 id="UI事件"><a href="#UI事件" class="headerlink" title="UI事件"></a>UI事件</h5></li>
<li>DOMActivate 表示元素被用户激活 ff和chrome支持</li>
<li>load事件 页面完全加载完在window上触发 所有框架都加载完毕在框架集上触发 图像加载完毕在img元素触发 嵌入的内容加载完毕在object上触发<br>怪不得要求onload写在赋值src属性之前，因为一旦设置src就会开始下载   如果是把onload写在src后面 有微小的可能性不触发onload<br>而script标签则需要src和添加到文档一起设置才会开始下载</li>
<li>unload 同上 当卸载后触发</li>
<li>abort 停止下载过程中 如果嵌入内容没有加载完 在object上面触发</li>
<li>error 同load 发生错误时触发</li>
<li>select 选择文本框中的一个或者多个字符时触发</li>
<li>resize 窗口或者框架大小发生变化时 在window或者框架上面触发此方法<br>触发的挺频繁  </li>
<li>scroll 滚动带有滚动条的元素内容时触发  </li>
</ul>
<h5 id="焦点事件"><a href="#焦点事件" class="headerlink" title="焦点事件"></a>焦点事件</h5><ul>
<li>blur失去焦点时触发</li>
<li>focus获得焦点时触发 focusout冒泡</li>
<li>focusin获得焦点触发 冒泡<h5 id="鼠标与滚轮事件"><a href="#鼠标与滚轮事件" class="headerlink" title="鼠标与滚轮事件"></a>鼠标与滚轮事件</h5>鼠标有9个事件</li>
<li>click </li>
<li>dbclick</li>
<li>mousedown 不能通过键盘触发</li>
<li>mouseenter 不冒泡 不能通过子元素触发</li>
<li>mouseleave</li>
<li>mousemove </li>
<li>mouseout 可以子元素触发</li>
<li>mouseup 松开鼠标触发</li>
<li>clientX和clientY表示鼠标 触发时的视口位置</li>
<li>pageX和pageY代表 鼠标页面位置</li>
<li>screenX和screenY表示 鼠标触发屏幕位置</li>
<li>shift ctrl alt cmd能影响鼠标事件 因此有四个布尔值表示是否按下  shiftKey ctrlKey altKey metaKey  </li>
<li>mousedown和mouseup有个button属性 0鼠标左键 1鼠标滚动 2鼠标右键</li>
<li>event还有点击多少次 属性</li>
<li>offsetX offsetY距离目标元素边界值</li>
<li>滚轮事件</li>
<li>mousewheel  wheelDelta 向前滚120倍数 向后滚-120倍数<h5 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h5></li>
<li>keydown keypress keyup </li>
<li>textInput事件 输入文本框之前触发</li>
<li>charCode 键码</li>
<li>后来变成了key和char</li>
<li>location属性 代表按下键盘那个位置 4代表虚拟键盘<h5 id="DOM变动事件"><a href="#DOM变动事件" class="headerlink" title="DOM变动事件"></a>DOM变动事件</h5></li>
<li>DOMSubtreeModified 监听DOM变动的事件</li>
<li>DOMNodeInserted 一个节点被作为子节点插入到另一个节点时触发</li>
<li>DOMNodeRemoved 节点从父节点中移除时触发</li>
<li>DOMNodeInsertedIntoDocument 节点插入文档或者通过子树插入到文档触发</li>
<li>DOMNodeRemoveFromDocument</li>
<li>DOMAttrModified 特性被修改时触发</li>
<li>DOMCharacterDataModified文本节点的值发生变化时触发<h5 id="各种页面事件还有很多啊"><a href="#各种页面事件还有很多啊" class="headerlink" title="各种页面事件还有很多啊"></a>各种页面事件还有很多啊</h5><h5 id="触摸事件"><a href="#触摸事件" class="headerlink" title="触摸事件"></a>触摸事件</h5></li>
<li>touchstart touchmove touchend 多了rotate scale属性<h5 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h5>事件委托就是在最外面冒泡的元素上面进行事件程序处理，这样就相当于只挂载一次事件处理程序，然后根据target元素来判断具体响应事件。好处是节约了内存，提高了性能，对象很快就可以访问 设置事件绑定也快了很多。<h5 id="移除事件处理程序"><a href="#移除事件处理程序" class="headerlink" title="移除事件处理程序"></a>移除事件处理程序</h5>不用的时候移除事件处理程序也是提高性能的一种方式，不过由于现代浏览器优良的性能，笔记这附近几种方法一般采用的比较少了。占用浏览器资源较多的一个方面主要是DOM的操作，因此减少重绘重拍等方式显得还是比较重要的。<h5 id="模拟事件"><a href="#模拟事件" class="headerlink" title="模拟事件"></a>模拟事件</h5>js可以模拟DOM事件，并与真的DOM事件一样使用 但是 需要传入大量的事件参数。。<h4 id="自定义事件-★★★★★"><a href="#自定义事件-★★★★★" class="headerlink" title="自定义事件 ★★★★★"></a>自定义事件 ★★★★★</h4>手写一个观察者模式的事件  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">EventTarget</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.handlers = []</span><br><span class="line">&#125;</span><br><span class="line">EventTarget.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: EventTarget,</span><br><span class="line">  addHandler: function (type, handler) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.handlers[type] == <span class="string">"undefined"</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.handlers[type] = []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用push的意思是同一种事件可以添加多个监听方法</span></span><br><span class="line">    <span class="keyword">this</span>.handlers[type].push(handler)</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  fire: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!event.target) &#123;</span><br><span class="line">      event.target = <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断事件类型有没有被绑定</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.handlers[event.type] <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> handlers = <span class="keyword">this</span>.handlers[event.type]</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; handlers.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 循环执行绑定的方法 并传入event参数</span></span><br><span class="line">        handlers[i](event)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  removeHandler: <span class="function"><span class="keyword">function</span> (<span class="params">type, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.handlers[type] <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> handlers = <span class="keyword">this</span>.handlers[type]</span><br><span class="line">      <span class="comment">// 循环判断同事件的方法 然后删除</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; handlers.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (handlers[i] === handler) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      handlers.splice(i, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用自定义事件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleMessage</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'Message received: '</span> + event.message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> target = <span class="keyword">new</span> EventTarget()</span><br><span class="line">target.addHandler(<span class="string">'message'</span>, handleMessage)</span><br><span class="line"><span class="built_in">console</span>.log(target);</span><br><span class="line"></span><br><span class="line">target.fire(&#123;</span><br><span class="line">  type: <span class="string">'message'</span>,</span><br><span class="line">  message: <span class="string">"Hello World!"</span></span><br><span class="line">&#125;)</span><br><span class="line">target.removeHandler(<span class="string">'message'</span>, handleMessage)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="表单脚本"><a href="#表单脚本" class="headerlink" title="表单脚本"></a>表单脚本</h3><p>基本表单常用方法和操作 详见红宝书420页</p>
<h4 id="操作剪贴板"><a href="#操作剪贴板" class="headerlink" title="操作剪贴板"></a>操作剪贴板</h4><ul>
<li>beforecopy 发生复制操作前触发</li>
<li>copy 发生复制操作时触发</li>
<li>beforecut 发生剪切操作前触发</li>
<li>cut 发生剪切操作时触发</li>
<li>beforepaste 发生粘贴操作前触发</li>
<li>paste 发生粘贴操作时触发<br>可以使用clipboardData对象访问剪切板数据 chrome中此对象存在于event对象中<br>这个对象有三个方法 getData() setData() clearData()  <h4 id="富文本-比较nb的-先过"><a href="#富文本-比较nb的-先过" class="headerlink" title="富文本 比较nb的 先过"></a>富文本 比较nb的 先过</h4><h3 id="canvas"><a href="#canvas" class="headerlink" title="canvas"></a>canvas</h3>getContext() 取得绘图上下文对象<br>绘制矩形  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cas = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'canvas'</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">var</span> ctx = cas.getContext(<span class="string">'2d'</span>)</span><br><span class="line">ctx.fillStyle = <span class="string">'#ff0000'</span></span><br><span class="line">ctx.fillRect(<span class="number">10</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">50</span>)</span><br><span class="line">ctx.fillStyle = <span class="string">'rgba(0,0,255,0.5)'</span></span><br><span class="line">ctx.fillRect(<span class="number">30</span>, <span class="number">30</span>, <span class="number">50</span>, <span class="number">50</span>)</span><br><span class="line">ctx.clearRect(<span class="number">40</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>canvas能绘制圆、矩形、线 能绘制路径 设置线的样式 图形样式 能增加渐变 能旋转 缩放<br> 不过问题是 旋转 缩放等变换是对ctx而不是某个图形进行的操作<br> getImgaeData() 取得原始图像数据 并且能对数据的元素点进行操作<br>isPointInPath方法必须要用路径画 用drawimg 并不行  </p>
<h4 id="webGL提供了一些操作字节级别的方法"><a href="#webGL提供了一些操作字节级别的方法" class="headerlink" title="webGL提供了一些操作字节级别的方法"></a>webGL提供了一些操作字节级别的方法</h4><h3 id="HTML5脚本编程"><a href="#HTML5脚本编程" class="headerlink" title="HTML5脚本编程"></a>HTML5脚本编程</h3><p>postMessage方法能进行frame之间的通讯  </p>
<h4 id="拖动"><a href="#拖动" class="headerlink" title="拖动"></a>拖动</h4><p>emmm 做一个拖动好麻烦啊<br><a href="http://www.zhangxinxu.com/wordpress/2011/02/html5-drag-drop-%E6%8B%96%E6%8B%BD%E4%B8%8E%E6%8B%96%E6%94%BE%E7%AE%80%E4%BB%8B/" target="_blank" rel="noopener">张鑫旭拖动</a><br>赶时间 pass</p>
<h3 id="ajax-XMLHttpRequest"><a href="#ajax-XMLHttpRequest" class="headerlink" title="ajax XMLHttpRequest"></a>ajax XMLHttpRequest</h3><p>手写ajax实现  </p>
<pre><code class="js"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()
xhr.addEventListener(<span class="string">'readystatechange'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
  <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) {
    <span class="keyword">if</span> (xhr.status === <span class="number">200</span> || xhr.status === <span class="number">304</span>) {
      <span class="built_in">console</span>.log(xhr.responseText);

    }
  }
})
<span class="keyword">var</span> url =
  <span class="string">'https://route.showapi.com/341-1?maxResult=20&amp;page=1&amp;showapi_appid=18393&amp;showapi_test_draft=false&amp;showapi_timestamp=20180605172845&amp;showapi_sign=1904d4ca2680fc3ad9e5922856e44803'</span>
xhr.open(<span class="string">'get'</span>, url, <span class="literal">true</span>)
xhr.send(<span class="literal">null</span>)
<span class="comment">//xhr.abort() //取消异步请求</span>
</code></pre>
<p>监听事件放在前面是为了兼容性。<br><code>xhr.setRequestHeader(&quot;MyHeader&quot;,&quot;MyValue&quot;)</code>方法修改头部信息。<br>get请求除了直接地址拼接参数之外，也可以使用addURLParam()方法添加参数 <code>url = addURLParam(url,&quot;name&quot;,&quot;Nick&quot;)</code><br>使用FormData提交表单数据  </p>
<pre><code class="js"><span class="keyword">var</span> data = <span class="keyword">new</span> FormData()
data.append(<span class="string">'name'</span>,<span class="string">'nick'</span>)
</code></pre>
<p>xhr的请求超时<br><code>xhr.timeout = 10000</code><br><code>xhr.ontimeout = function(){}</code><br>progress事件监听请求进度<br>lengthComputable 表示进度信息是否可用的布尔值<br>position 表示已经接收的字节数<br>totalSize表示根据content-length响应头部确定的预期字节数    </p>
<h4 id="websocket-并不难"><a href="#websocket-并不难" class="headerlink" title="websocket 并不难"></a>websocket 并不难</h4><p><a href="http://www.cnblogs.com/stoneniqiu/p/5402311.html" target="_blank" rel="noopener">node+html 实现websocket</a>  </p>
<h3 id="js高级技巧"><a href="#js高级技巧" class="headerlink" title="js高级技巧"></a>js高级技巧</h3><p>P598</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Xavier</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://blog.xaviershi.com/2018/05/14/JS高级-一刷红宝书/">http://blog.xaviershi.com/2018/05/14/JS高级-一刷红宝书/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明来自 <a href="http://blog.xaviershi.com" target="_blank">XS's Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/js/">js</a></div><elif theme.sharejs && theme.sharejs.enable><div class="social-share" data-disabled="diandian"></div><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script></elif></article><nav id="pagination"><div class="prev-post pull-left"><a href="/2018/07/12/移动端适配几个简单解决办法(vue)/"><i class="fa fa-chevron-left">  </i><span>关于移动端适配的几个简单解决办法(vue)</span></a></div></nav><div id="disqus_thread"></div><script>var disqus_config = function () {
  this.page.url = 'http://blog.xaviershi.com/2018/05/14/JS高级-一刷红宝书/';
  this.page.identifier = '2018/05/14/JS高级-一刷红宝书/';
  this.page.title = 'JS高级-一刷红宝书';
}
var d = document, s = d.createElement('script');
s.src = "https://firstaurorablog.disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-src" src="https://firstaurorablog.disqus.com/count.js" async></script><elif theme.laibili && theme.laibili.enable></elif><elif theme.gitment && theme.gitment.enable></elif></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2017 - 2019 By Xavier</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.4.1"></script><script src="/js/fancybox.js?version=1.4.1"></script><script src="/js/sidebar.js?version=1.4.1"></script><script src="/js/copy.js?version=1.4.1"></script><script src="/js/fireworks.js?version=1.4.1"></script><script src="/js/transition.js?version=1.4.1"></script><script src="/js/scroll.js?version=1.4.1"></script><script src="/js/head.js?version=1.4.1"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/z16.model.json"},"display":{"position":"right","width":150,"height":250},"mobile":{"show":false},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false,"tagMode":false});</script></body></html>